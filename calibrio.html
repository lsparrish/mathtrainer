<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calibrio</title>
    <style>
    body { font-family: sans-serif; text-align: center; background: #fff; color: #000; }
    @media (prefers-color-scheme: dark) { body { background: #000; color: #fff; } }
    #problem { font-size: 2em; height: 2em; line-height: 2em; display: inline-block; min-width: 200px; border-radius: 0; transition: all 0.1s ease; text-align: center;  }
    .fraction { display: inline-block; vertical-align: middle; line-height: 1em; }
    .fraction > div { display: block; text-align: center; font-size: 0.5em; line-height: 1em; }
    .fraction > div:first-child { border-bottom: .15em solid currentColor; }
    .nonfraction > div { font-size: 0.5em; display: inline-block; line-height: 1em; vertical-align: middle; }
    #stats { font-size: 1em; margin-top: 10px; display: flex; gap: 10px; justify-content: center; }
    #info { display: inline-block;margin: 20px 0; font-size: 0.8em; max-width: 300px; }
    #buttons { display: flex; justify-content: center; gap: 5px; }
    #buttons button { font-size: 2em; width: 50px; height: 50px; line-height: 50px; border-radius: 5px; background: #f0f0f0; color: #000; border: 1px solid #ccc; transition: background 0.2s, transform 0.1s; display: flex; align-items: center; justify-content: center; }
    #buttons button:hover { background: #ddd; }
    #buttons button:active { transform: scale(0.95); }
    @media (prefers-color-scheme: dark) { #buttons button { background: #333; color: #fff; border: 1px solid #555; } 
    #buttons button:hover { background: #444; } }
    #score { font-size: 1.5em; margin-top: 10px; }
    @media (max-width: 600px) { body { padding: 10px; } #problem { font-size: 2.5em; } }
    .hidden { display: none; visibility: hidden; }

    </style>
</head>
<body>
    <div id="problem"></div>
    <div id="stats"><span id="avg">1.00s</span><span id="timer">0.00s</span></div>
    <div id="buttons"><button>0</button><button>1</button><button>2</button><button>3</button><button>4</button></div>
    <div id="info">
        <b>Usage</b>: Answers are mod 5 (0-4). Key ranges 0-9 map to mod 5. Press Z to toggle zeros.<br>
        <b>Timer</b>: Resets on wrong answers. Correct answers only count after 1/2 average response time. Press T to toggle extras, O for specific operations (add, subtract, multiply, divide).<br>
        <b>Purpose</b>: A skill calibration trainer that highlights gaps in modulus 5 math fact automaticity. Wrong answers reset the timer but don't affect average time. Number range expands as you improve.
    </div>
    <div id="score">Score: 0</div>
    <script>
        const ops = ['+', '-', '*', '/'];
        const mod = 5;
        let records = {};
        let points = 0;
        let avoid0 = true;
        let current_max = 5;
        let last_ans = -1;
        let start_time = Date.now();
        let paused = false;
        let pause_start = 0;
        let interval_id = setInterval(update_timer, 100);
        let current_key, current_ans, current_avg;
        let opModes = ['', '+', '-', '*', '/'];
        let currentOpIndex = 0;
        let selectedOp = opModes[currentOpIndex];
        const problem = document.getElementById('problem');
        const avg_span = document.getElementById('avg');
        const timer_span = document.getElementById('timer');
        const score_span = document.getElementById('score');
        const info = document.getElementById('info');
        const buttons_div = document.getElementById('buttons');
        const stats = document.getElementById('stats');
        const extras = [info, stats, score_span];
        const isMobile = (window.outerWidth <= 667 || window.outerHeight <= 667);
        if (!isMobile) { buttons_div.classList.add('hidden'); } else { buttons_div.classList?.remove('hidden'); }
        buttons_div.querySelectorAll('button').forEach((btn, i) => btn.addEventListener('click', () => answer(i)));
        problem.addEventListener('click', toggle_extras);
        document.addEventListener('keydown', handle_key);

        function modInverse(a, m) {
            a = (a % m + m) % m;
            for (let i = 1; i < m; i++) {
                if ((a * i) % m === 1) return i;
            }
            return 1;
        }

        function compute_ans(a, op, b) {
            let res;
            if (op === '+') res = a + b;
            else if (op === '-') res = a - b;
            else if (op === '*') res = a * b;
            else {
                let bm = b % mod;
                if (bm === 0) return null;
                let inv = modInverse(bm, mod);
                res = (a % mod * inv) % mod;
            }
            return (res % mod + mod) % mod;
        }

        function getProgressColors(progress) {
            const isDark = isDarkMode();
            if (isDark) {
                if (progress <= 0.5) {
                    const localProgress = progress * 2;
                    const red = Math.round(127 * (1 - localProgress) + 6 * localProgress);
                    const green = Math.round(29 * (1 - localProgress) + 78 * localProgress);
                    const blue = Math.round(29 * (1 - localProgress) + 59 * localProgress);
                    return {
                        bg: `rgb(${red}, ${green}, ${blue})`,
                        text: '#6ee7b7'
                    };
                } else {
                    return {
                        bg: '#064e3b',
                        text: '#6ee7b7'
                    };
                }
            } else {
                const intensity = Math.round(240 - (progress * 60));
                return {
                    bg: `rgb(${intensity}, ${intensity}, ${intensity})`,
                    text: '#000000'
                };
            }
        }
        function generate_problem() {
            let min_num = avoid0 ? 1 : 0;
            current_max = 5 + Math.floor(points / 10);
            let a, b, op, ans;
            while (true) {
                op = selectedOp || (op = ops[Math.floor(Math.random() * ops.length)]);
                a = Math.floor(Math.random() * (current_max - min_num + 1)) + min_num;
                b = Math.floor(Math.random() * (current_max - min_num + 1)) + min_num;
                if (op === '/' && (b % mod === 0 || a % b !== 0)) continue;
                if (op === '/' && avoid0 && a < b) continue;
                if (op === '-' && avoid0 && a < b) continue;
                ans = compute_ans(a, op, b);
                if (ans === null) continue;
                if (ans === last_ans || (avoid0 && ans === 0)) continue;
                break;
            }
            last_ans = ans;
            current_ans = ans;
            const mod5text=`<span style="font-size:0.4em; vertical-align: middle;">mod5</span>`;
            if (op === '/') {
                problem.innerHTML = `<div class="fraction"><div>${a}</div><div>${b}</div></div> ${mod5text}`;
                current_key = `${a}/${b}`;
            } else {
                problem.innerHTML = `<div class="nonfraction">${a} ${op} ${b} ${mod5text}</div>`;
                current_key = `${a}${op}${b}`;
            }
            if (!records[current_key]) records[current_key] = { sum: 0, count: 0 };
            current_avg = records[current_key].count > 0 ? records[current_key].sum / records[current_key].count : 1;
            avg_span.textContent = current_avg.toFixed(2) + 's';
            start_time = Date.now();
            const colors = getProgressColors(0);
            problem.style.backgroundColor = colors.bg;
            problem.style.color = colors.text;
        }
        function update_timer() {
            if (paused) return;
            let t = (Date.now() - start_time) / 1000;
            timer_span.textContent = t.toFixed(2) + 's';
            let progress = Math.min(t / current_avg, 1);
            const colors = getProgressColors(progress);
            problem.style.backgroundColor = colors.bg;
            problem.style.color = colors.text;
        }
        function reset_timer() {
            start_time = Date.now();
        }
        function toggle_extras() {
            extras.forEach(el => el.classList.toggle('hidden'));
        }
        function isDarkMode() {
            return window.matchMedia('(prefers-color-scheme: dark)').matches;
        }
        function handle_key(e) {
            let key = e.key;
            if (key >= '0' && key <= '9') answer(parseInt(key % 5));
            else if (key === ' ') {
                paused = !paused;
                if (paused) pause_start = Date.now();
                else start_time += Date.now() - pause_start;
            } else if (key.toLowerCase() === 't') toggle_extras();
            else if (key.toLowerCase() === 'z') {
                avoid0 = !avoid0;
                generate_problem();
            } else if (key.toLowerCase() === 'o') {
                currentOpIndex = (currentOpIndex + 1) % opModes.length;
                selectedOp = opModes[currentOpIndex];
                generate_problem();
            }
        }

        function answer(user_ans) {
            if (paused) return;
            let t = (Date.now() - start_time) / 1000;
            if (user_ans !== current_ans) {
                reset_timer();
                const colors = getProgressColors(0);
                problem.style.backgroundColor = colors.bg;
                problem.style.color = colors.text;
                return;
            }
            (t >= 10) && (t = 10); // in case you forgot to pause
            if (t > current_avg / 2) {
                points++;
                score_span.textContent = `Score: ${points}`;
                let rec = records[current_key];
                rec.sum += t;
                rec.count++;
                current_avg = rec.sum / rec.count;
                avg_span.textContent = current_avg.toFixed(2) + 's';
                generate_problem();
            }
        }
        generate_problem();
    </script>
</body>
</html>
